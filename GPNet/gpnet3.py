# -*- coding: utf-8 -*-
"""GPNet3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nVXEfFvJB8RitwoQpPTO_dtqlsC95k3B
"""

import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F 
import torch.optim as optim

class GPNet3(nn.Module):
  def __init__(self):
    super(GPNet3, self).__init__()
    self.fc1 = nn.Linear(6, 50)
    self.fc2 = nn.Linear(50, 50)
    self.fc3 = nn.Linear(50, 4)
    self.JHist = []
      
  def forward(self, x):
    x = self.standardize_data(x)
    x = torch.tanh(self.fc1(x))
    x = torch.tanh(self.fc2(x))
    x = self.fc3(x)
    return x

  def standardize_info(self, train_x):
    self.mean = torch.mean(train_x, 0)
    self.std = train_x.std(0)
  
  def standardize_data(self, train_x):
    return (train_x - self.mean) / self.std

  def fit(self, train_x, train_y, batch_size=128, epochs=800, lr=0.01, showLoss=False):
    if len(self.JHist) == 0:
      self.standardize_info(train_x)

    optimizer = optim.SGD(self.parameters(), lr=lr)
    criterion = nn.MSELoss()

    data_size = train_x.shape[0]
    num_batches = int(data_size / batch_size)
    for e in range(epochs):
      
      epoch_loss = 0

      for b in range(num_batches):
        x_batch = train_x[b*batch_size:min((b+1)*batch_size, data_size),:]
        y_batch = train_y[b*batch_size:min((b+1)*batch_size, data_size),:]
        
        optimizer.zero_grad()

        y_pred = net(x_batch) # define input

        loss = criterion(y_pred, y_batch)
        loss.backward()
        optimizer.step()

        epoch_loss += loss.item()

      if e % 100 == 99 and showLoss:
        print(e + 1, epoch_loss)

      self.JHist.append(epoch_loss)

if __name__ == "__main__":
  savedData = torch.from_numpy(np.loadtxt('data.csv', delimiter=','))

  input, output = savedData[:,:6], savedData[:,6:]
  train_x, test_x = input[:10000,:], input[10000:,:]
  train_y, test_y = output[:10000,:], output[10000:,:]
  print(train_x[5,:])

  net = GPNet3().double()
  print(net)

  net.fit(train_x, train_y, epochs=300, lr=0.00025, showLoss=False)

  import matplotlib.pyplot as plt
  plt.plot(net.JHist)
  plt.ylabel("cost error")
  plt.xlabel("epoch")
  plt.show()

  with torch.no_grad():
    criterion = nn.MSELoss()
    y_pred = net(test_x)
    loss = criterion(y_pred, test_y)
    print(loss.item())
    print(y_pred[7,:])
    print(test_y[7,:])

  print(net.JHist)

  PATH = './GPNet3.pth'
  torch.save(net.state_dict(), PATH)